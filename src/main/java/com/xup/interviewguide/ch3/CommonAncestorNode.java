package com.xup.interviewguide.ch3;

public class CommonAncestorNode {

    /*
    * 通过比较两个节点中序或者后序遍历时到根节点的路径，
    * 就可以得到公共祖先。采用这种思路，需要保存所有节点
    * 到根节点的路径，每个节点的路径的长度为O(h)，同时在
    * 比较路径时需要花的时间为为O(h)。所以这个方法的时间
    * 复杂度为O(n+m*h),空间复杂度为O(n*h)。
    *
    * 在上面的方法中，存在重复的比较，例如，一个节点的深度
    * 很深，也就是它到根节点的路径很长。现在要求它的左节点
    * 和右节点的公共祖先，那么比较路径时，从根节点开始一直到
    * 当前节点才能发现公共节点。实际上已经知道这两个节点
    * 分别位于一棵子树的左边和右边，那么公共祖先节点就是
    * 当前子树的根节点。
    *
    * 那么怎么判断需要比较的两个节点位于哪一棵子树上？
    * 通过先查找左子树后查找右子树的顺序，查找到第一个节点之后，
    * 首先是在以第一个节点为根的子树中查找第二个节点，然后
    * 依次在其祖先节点为根的子树中查找第二节点。查找到第二个
    * 节点时就知道两个节点分别位于当前子树的左右两边，所以公共
    * 祖先就是当前子树的根节点。
    *
    * 根据前面的分析，在遍历的过程中
     */
}
